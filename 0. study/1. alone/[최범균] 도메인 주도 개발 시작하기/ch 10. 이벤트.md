# 10. 이벤트

## 10.1 시스템 간 강결합 문제

me. 두 관심사가 묶여있으니 이것을 분리하자

1. 트랜잭션 관심사 분리

2. 외부 API 호출일 경우 성능에 대한 문제

## 10.2 이벤트 개요

- 이벤트
  - (클래스 이름) 이벤트 종류
  - 이벤트 발생 시간
  - 기타: 주문번호, 신규 배송지 등 이벤트와 관련된 정보

- 이벤트 생성주체
- 발행자 = 이벤트 디스패처 = 이벤트 퍼블리셔
- 구독자 = 이벤트 핸들러 = 이벤트 구독자

### 10.2.3 이벤트 용도

`어따 쓸거얌?? ><`

1. 트리거
  - 도멘 상태 변경 후 후처리

1. 데이터 동기화
  - ex.1) 배송지 변경후 외부 배송 서비스와 동기화
  - ex.2) CQRS 를  위한 조회를 동기화

### 10.2.4. 이벤트 장점

관심사의 분리로 인한 기능 확장 유리

## 10.3 이벤트, 핸들러, 디스패처 구현

생략! 여러가지 구현 스타일이 나뉜당...

## 10.4 동기 이벤트 처리 문제

동기적으로 진행되면 외부 API 등이 엮여있을 경우 

1. 타 서비스의 성능 저하가 전파된다
2. 트랜잭션으로 묶일 필요가 없을 때도 묶이게 된다

## 10.5 비동기 이벤트 처리

사실 많은 경우가 `A한 후에 B 하기` 는 `A하면 언제까지 B 하기`인 경우가 많다

B를 실패한 경우 재시도/ 수동 처리를 해도 되기도 함

-> B하기를 별도 **쓰레드 핸들러**로 구현

## 105.1 로컬 핸들러

**@Async**

스프링이 알아서 비동기로 쓰레드 만들어줌

- 다만 AOP 기술의 한계로 별도의 객체에서 호출해야하는 것으로 알고 있음 (프록시의 한계)
  - 재확인해야 할 필요

## 10.5.2 메시지 큐

**토끼MQ**, **갓프카**

## 10.5.3 이벤트 저장소를 이용한 비동기 처리

- 저장소에 주기적(`@Scheduled`)으로 이벤트 저장
- 포워더(별도 쓰레드)는 주기적으로 데이터를 읽어와서 전달

## 10.6 이벤트 적용 시 추가 고려 사항

1. 어떤 애그리거트가 발행했는지에 대한 정보가 필요하다면 추가할 것
2. 특정 이벤트가 계속 전송 실패를 해서 다음 이벤트를 전송 못한다면? 최대 전송 횟수 제한 걸기
3. 이벤트 실패시 이벤트 히스토리에 대한 손실
4. 이벤트 순서가 보장되야 할 경우
5. 동일 이벤트가 다시 올 경우에 대한 처리

### 10.6.1 이벤트 처리와 DB 트랜잭션 고려

@Transactional(phase = TransactionPhase.AFTER_COMMIT)

- 스프링 트랜잭션 커밋에 성공한 뒤에 핸들러 메서드 실행