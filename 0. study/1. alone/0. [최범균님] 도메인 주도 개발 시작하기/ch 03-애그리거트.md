# chapter 3. 애그리거트

## 3.1 애그리거트

도메인 모델이 복잡해지면 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어렵다.

상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 이것이 애그리거트

### `반례` 애그리거트가 아닌 경우

다만 'A가 B를 갖는다'의 경우 애그리거트로 생각하기 쉽다. 반드시 그렇지 않다.

상품과 리뷰가 그런 예로, 

- `라이프 사이클 다름`: 함께 생성되지도, 함께 변경되지도 않는다.
- `Proudct(상품)`을 변경하는 주체가 상품담당자, `Review(리뷰)`를 생성하고 변경하는 주체는 고객

### 적절한 애그리거트 규모

도메인 규칙을 제대로 이해할 수록 애그리거트의 실제 크기는 줄어든다.

- 한 개의 엔티티 객체를 갖는 애그리거트가 다수
- 두 개이상은 드물었다.

## 3.2 애그리거트 루트

- `역할`: 도메인 규칙을 지키기 위해 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- `정의`: 모든 객체가 일관된 상태 유지를 하기 위한 관리 주체

### 3.2.1 도메인 규칙과 일관성

- 역할
  - 애그리거트에 속한 객체를 포함
  - 일관성이 깨지지 않도록 함

- 응용 서비스에 비즈니스가 분산되면 동일 로직을 여러 응용 서비스에 중복 구현 가능성이 있고 유지보수에 도움이 되지 않는다.

- 공개 set메서드는 도메인의 의미, 의도를 표현하지 못하고 도메인 로직을 응용 영역이나 표현 영역으로 분산시킨다. 도메인 로직이 한 곳에 응집되지 않는다.

### 3.2.2 애그리거트 루트의 기능 구현

애그리거트 루트 역할
- 상태 참조
- 기능 실행을 위임

### 3.2.3 트랜잭션 범위

- 잠금 대상이 많아진다는 것: 동시 처리 트랜잭션 개수가 줄어듦 -> 전체적인 성능(처리량) 떨어뜨림.

- 한 트랜잭션에서 한 애그리거트 수정 -> 애그리거트에서 다른 애그리거트 변경하지 않는 것.

- 애그리거트는 최대한 독립적이어야 한다 -> 다른 Aggr을 의존하면 결합도 높아질 수 있음

- 도메인 이벤트 사용시 한 Tx에서 한 Aggr 수정하면서 동기/비동기로 다른 Aggr 상태 변경하는 코드를 작성할 수 있음

- 한 Tx에서 둘 이상의 Aggr 변경하는 것을 고려하는 경우
  - 팀 표준
  - 기술 제약: 프레임워크에서 이벤트 방식 제공 X
  - UI 구현의 편리

## 3.3 리포지토리와 애그리거트

- 저장할 때 애그리거트 전체를 영속화
  - 모든 변경을 원자적으로 저장소에 반영
- 불러올 때 완전한 애그리거트 제공
  - 그렇지 않으면 NPE 발생 가능

## 3.4 ID를 이용한 애그리거트 참조

물리적 연결을 제거하여 모델의 복잡돌르 낮추어준다.
Aggr간 의존 제거 -> 응집도를 높임

Ref를 가질 떄의 문제 3 가지

### 편한 탐색 오용

한 Aggr가 관리하는 범위는 자기 자신으로 한정해야한다

- 만일 Ref로 갖게 되면 다른 Aggr 쉽게 변경할 수 있음
  - 다른 Aggr 건드리기 쉬워짐
  - 의존 결합도 높아짐

### 성능 문제

지연 로딩과 즉시 로딩 사이에서 고민해야 한다.


### 확장

하위 도메인별로 시스템 분리할 수 없다


### ID를 이용한 참조와 조회 성능

조회전용 DAO를 만든다.
관련 Aggr 모두 조회시 캐시 적용하거나 조회 전용 저장소 따로 구성한다.

## 3.5 애그리거트 간 집합 연관 (다시 읽기)

현실적으로 성능을 고려하여 모든 연관 객체를 가져올 수 없다.

그 경우 ID를 이용한 조회를 한다.

## 3.6 애그리거트를 팩토리로 사용하기

응용 서비스 계층에 복잡한 엔티티 생성 코드가 있을 경우, 애그리거트에 이 역할을 위임한다.

만일 생성시 많은 정보가 필요하다면 애그리거트 팩토리가 다른 팩토리에 위임을 할 수 있다.

